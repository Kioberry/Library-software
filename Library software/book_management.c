#pragma once
#include "book_management.h"
#include <stdio.h>
#include <stdlib.h>

/*You can extend the structs (Book and BookList) defined in this head file;
  However, you may not change the function prototypes.
  You are also free to add additional head files and data structures as needed.
*/
//saves the database of books in the specified file
//returns 0 if books were stored correctly, or an error code otherwise
int store_books(FILE* file) {
	//FILE* fp = fopen("book.txt", "wb");
	Book* p = bhead->next;
	while (p) {
		char str1[100];
		char str2[100];
		strcpy(str1, p->title);
		strcpy(str2, p->title);
		int i0 = 0;
		for (i0 = 0; i0 < strlen(str1); i0++) {
			if (str1[i0] == ' ') {
				str1[i0] = '_';
			}
		}
		for (i0 = 0; i0 < strlen(str2); i0++) {
			if (str2[i0] == ' ') {
				str2[i0] = '_';
			}
		}
		fprintf(file, "%d %s %s %d %d %d\n", &(p->id), str1, str2, &(p->year), &(p->copies), &(p->originc));
		p = p->next;
	}
	fclose(file);
	return 0;
}
void add_bookhead(Book* node)
{
	Book* p = bhead;
	while (p) {
		if (p->next == NULL) {
			p->next = node;
		}
		p = p->next;
	}
}
//loads the database of books from the specified file
//the file must have been generated by a previous call to store_books()
//returns 0 if books were loaded correctly, or an error code otherwise
int load_books(FILE* file) {
	//FILE* fp = fopen("book.txt", "rb");
	if (file == NULL)
	{
		return 0;
	}
	int id;
	char title[100];
	char authors[100];
	int year;
	int cop;
	int ori;
	while (1) {
		/*printf("12333");*/
		int tag = fscanf(file, "%d %s %s %d %d %d", &id, title, authors, &year, &cop, &ori);
		/*printf("12333");*/
		if (tag == -1)break;
		int i0 = 0;
		for (i0 = 0; i0 < strlen(title); i0++) {
			if (title[i0] == '_') title[i0] = ' ';
		}
		for (i0 = 0; i0 < strlen(authors); i0++) {
			if (authors[i0] == '_')authors[i0] = ' ';
		}
		Book* node = (Book*)calloc(1, sizeof(Book));
		node->id = id;
		node->title = (char*)calloc(1, 100 * sizeof(char));
		node->authors = (char*)calloc(1, 100 * sizeof(char));
		strcpy(node->title, title);
		strcpy(node->authors, authors);
		node->year = year;
		node->copies = cop;
		node->originc = ori;
		add_bookhead(node);

	}
	fclose(file);
	return 0;
}

//adds a book to the ones available to the library
//returns 0 if the book could be added, or an error code otherwise
int add_book(Book book) {
	//printf("id:%d\n", book.id);
	//printf("title:%s\n", book.title);
	//printf("authors:%s\n", book.authors);
	//printf("year:%d\n", book.year);
	//printf("copies:%d\n", book.copies);
	//printf("orignc:%d\n", book.originc);
	//getch();
	Book* node = (Book*)calloc(1, sizeof(Book));
	*node = book;
	node->next = NULL;
	Book* p = bhead;
	while (p) {
		if (p->next == NULL) {
			p->next = node;
			break;
		}
		p = p->next;
	}
	return 0;
}

//removes a book from the library
//returns 0 if the book could be successfully removed, or an error code otherwise.
int remove_book(Book book)
{
	Book* p = bhead->next;
	Book* pre = bhead;
	while (p)
	{
		if (p->id == book.id)
		{
			if (p->copies != p->originc) {
				printf("error copies!=originc\n");
				return 1;
			}
			pre->next = p->next;
			free(p->title);
			free(p->authors);
			free(p);
			return 0;
		}
		p = p->next;
		pre = pre->next;
	}
	return 1;
}

//finds books with a given title.
//returns a BookList structure, where the field "list" is a list of books, or null if no book with the 
//provided title can be found. The length of the list is also recorded in the returned structure, with 0 in case
//list is the NULL pointer.
BookList find_book_by_title(const char* title) {
	Book* p = bhead->next;
	BookList list0;
	list0.list = (Book*)calloc(1, sizeof(Book));
	list0.length = 0;
	while (p) {
		if (strcmp(p->title, title) == 0) {
			Book* q = (Book*)calloc(1, sizeof(Book));
			*q = *p;
			q->next = list0.list->next;
			list0.list->next = q;
			list0.length++;
		}
		p = p->next;
	}
	return list0;
}

//finds books with the given authors.
//returns a Booklist structure, where the field "list" is a newly allocated list of books, or null if no book with the 
//provided title can be found. The length of the list is also recorded in the returned structure, with 0 in case
//list is the NULL pointer.
BookList find_book_by_author(const char* author) {
	Book* p = bhead->next;
	BookList list0;
	list0.list = (Book*)calloc(1, sizeof(Book));
	list0.length = 0;
	while (p) {
		if (strcmp(p->authors, author) == 0) {
			Book* q = (Book*)calloc(1, sizeof(Book));
			*q = *p;
			q->next = list0.list->next;
			list0.list->next = q;
			list0.length++;
		}
		p = p->next;
	}
	return list0;
}

//finds books published in the given year.
//returns a Booklist structure, where the field "list" is a list of books, or null if no book with the 
//provided title can be found. The length of the list is also recorded in the returned structure, with 0 in case
//list is the NULL pointer.
BookList find_book_by_year(unsigned int year) {
	Book* p = bhead->next;
	BookList list0;
	list0.list = (Book*)calloc(1, sizeof(Book));
	list0.length = 0;
	while (p) {
		if (p->year == year) {
			Book* q = (Book*)calloc(1, sizeof(Book));
			*q = *p;
			q->next = list0.list->next;
			list0.list->next = q;
			list0.length++;
		}
		p = p->next;
	}
	return list0;
}