#pragma once
#include "book_management.h"
#include <stdio.h>
#include <stdlib.h>

/*You can extend the structs (Book and BookList) defined in this head file;
  However, you may not change the function prototypes.
  You are also free to add additional head files and data structures as needed.
*/
//saves the database of books in the specified file
//returns 0 if books were stored correctly, or an error code otherwise
int store_books(FILE* file) {
	FILE* fp = fopen("book.txt", "wb");
	Book* p = bhead->next;
	while (p) {
		fscanf(fp, "%d|%[^|]|%[^|]|%d|%d|%d\n", &(p->id), p->title, p->authors, &(p->year), &(p->copies), &(p->originc));
		p = p->next;
	}
	fclose(fp);
}

void add_bookhead(Book* node)
{
	Book* p = bhead;
	while (p) {
		if (p->next == NULL) {
			p->next = node;
		}
		p = p->next;
	}
}

//loads the database of books from the specified file
//the file must have been generated by a previous call to store_books()
//returns 0 if books were loaded correctly, or an error code otherwise
int load_books(FILE* file) {
	FILE* fp = fopen("book.txt", "rb");
	int id;
	char title[50];
	char authors[50];
	int year;
	int cop;
	int ori;
	while (1) {
		int tag = fscanf(file, "%d|%[^|]|%[^|]|%d|%d|%d", &id, title, authors, &year, &cop, &ori);
		if (tag == -1)break;
		Book* node = (Book*)calloc(1, sizeof(Book));
		node->id = id;
		strcpy(node->title, title);
		strcpy(node->authors, authors);
		node->year = year;
		node->copies = cop;
		node->originc = ori;
		add_bookhead(node);

	}
	fclose(fp);
}

//adds a book to the ones available to the library
//returns 0 if the book could be added, or an error code otherwise
int add_book(Book book) {
	//printf("id:%d\n", book.id);
	//printf("title:%s\n", book.title);
	//printf("authors:%s\n", book.authors);
	//printf("year:%d\n", book.year);
	//printf("copies:%d\n", book.copies);
	//printf("orignc:%d\n", book.originc);
	//getch();
	Book* node = (Book*)calloc(1, sizeof(Book));
	*node = book;
	node->next = NULL;
	Book* p = bhead;
	while (p) {
		if (p->next == NULL) {
			p->next = node;
			break;
		}
		p = p->next;
	}
	return 0;
}

//removes a book from the library
//returns 0 if the book could be successfully removed, or an error code otherwise.
int remove_book(Book book) {
	Book* p = bhead->next;
	Book* pre = bhead;
	while (p) {
		if (p->id == book.id) {
			pre->next = p->next;
			free(p->title);
			free(p->authors);
			free(p);
			return 0;
		}
		p = p->next;
		pre = pre->next;
	}
	return 1;
}

//finds books with a given title.
//returns a BookList structure, where the field "list" is a list of books, or null if no book with the 
//provided title can be found. The length of the list is also recorded in the returned structure, with 0 in case
//list is the NULL pointer.
BookList find_book_by_title(const char* title) {
	Book* p = bhead;
	BookList list0;
	list0.length = 0;
	while (p) {
		if (strcmp(p->title, title) == 0) {
			list0.length++;
			Book* node = (Book*)calloc(1, sizeof(Book));
			*node = *p;
			node->next = NULL;
			if (list0.length == 0) {
				list0.list = node;
			}
			else {
				Book* q = list0.list;
				while (q) {
					if (q->next == NULL) {
						q->next = node;

					}
					q = q->next;
				}
			}
		}
		p = p->next;
	}
	return list0;
}

//finds books with the given authors.
//returns a Booklist structure, where the field "list" is a newly allocated list of books, or null if no book with the 
//provided title can be found. The length of the list is also recorded in the returned structure, with 0 in case
//list is the NULL pointer.
BookList find_book_by_author(const char* author) {
	Book* p = bhead;
	BookList list0;
	list0.length = 0;
	while (p) {
		if (strcmp(p->authors, author) == 0) {
			list0.length++;
			Book* node = (Book*)calloc(1, sizeof(Book));
			*node = *p;
			node->next = NULL;
			if (list0.length == 0) {
				list0.list = node;
			}
			else {
				Book* q = list0.list;
				while (q) {
					if (q->next == NULL) {
						q->next = node;

					}
					q = q->next;
				}
			}
		}
		p = p->next;
	}
	return list0;
}

//finds books published in the given year.
//returns a Booklist structure, where the field "list" is a list of books, or null if no book with the 
//provided title can be found. The length of the list is also recorded in the returned structure, with 0 in case
//list is the NULL pointer.
BookList find_book_by_year(unsigned int year) {
	Book* p = bhead;
	BookList list0;
	list0.length = 0;
	while (p) {
		if (p->year == year) {
			list0.length++;
			Book* node = (Book*)calloc(1, sizeof(Book));
			*node = *p;
			node->next = NULL;
			if (list0.length == 0) {
				list0.list = node;
			}
			else {
				Book* q = list0.list;
				while (q) {
					if (q->next == NULL) {
						q->next = node;

					}
					q = q->next;
				}
			}
		}
		p = p->next;
	}
	return list0;
}